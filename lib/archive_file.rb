require 'support/number_helper'
class MalwareArchive
  include NumberHelper

### Class Methods  
  @@filepath = nil # @@ += class variable
  def self.filepath=(path=nil)
    @@filepath = File.join(APP_ROOT, path)
  end
  
  attr_accessor :filename, :filetype, :filesize, :md5, :sha1, :sha256, :sha512, :crc32, :ssdeep
  
  def self.file_exists? # 1/3 class methods because they have self at the beginning
    # class should know if the malware archive file exists
    if @@filepath && File.exists?(@@filepath) # will check and see if the path has been set, & exists 
      return true
    else
      return false
    end
  end
  
  def self.file_usable? # boolean test instead of writing longer if/else/then statements to check file
    return false unless @@filepath
    return false unless File.exists?(@@filepath)
    return false unless File.readable?(@@filepath)
    return false unless File.writable?(@@filepath)
    return true
  end
  
  def self.create_file # 2/3 class methods because they have self at the beginning
    # create the malware archive file
    File.open(@@filepath, 'w') unless file_exists? # open file if exists in write mode
    return file_usable? # return as a boolean if file is usable
  end
  
  def self.saved_malware_archives # 3/3 class methods because they have self at the beginning
 archive_list = []
 #malware_archives = []
 if file_usable?
   file = File.new(@@filepath, 'r')
   file.each_line do |line|
     
     #malware_archives << MalwareArchive.new.import_line(line.chomp)
     archive_list << MalwareArchive.new.import_line(line.chomp)
   end
   file.close
 end
 return archive_list
end

### Instance Methods

# This is a very common pattern that you will see in the creation of attributes in the initialize method
# Well look for some values in the argvs, if not set, then we default to a default value
# like an empty string in this case

def self.build_using_questions
    args = {}
  print "Enter File name: "
  args[:filename] = gets.chomp.strip
  
  print "Enter File type: "
  args[:filetype] = gets.chomp.strip
  
  print "Enter File size: "
  args[:filesize] = gets.chomp.strip

  print "Enter MD5 sum: "
  args[:md5] = gets.chomp.strip
    
  print "Enter SHA1 sum: "
  args[:sha1] = gets.chomp.strip
  
  print "Enter SHA256 sum: "
  args[:sha256] = gets.chomp.strip
  
  print "Enter SHA512 sum: "
  args[:sha512] = gets.chomp.strip
  
  print "Enter CRC32 sum: "
  args[:crc32] = gets.chomp.strip
  
  print "Enter Ssdeep sum: "
  args[:ssdeep] = gets.chomp.strip

  return self.new(args)
   
end

  def initialize(args={}) # empty hash in case user doesnt pass any argvs to the application it will still do the initialization
    @filename = args[:filename] || "" # if we do get a hash/name, lets set argvs to filename
    @filetype = args[:filetype] || "" # if we dont get a name sent we will get nil.
    @filesize = args[:filesize] || "" # so we will default to an empty string because empty string is better than nil
    @md5      = args[:md5] || ""
    @sha1     = args[:sha1] || ""
    @sha256   = args[:sha256] || ""
    @sha512   = args[:sha512] || ""
    @crc32    = args[:crc32] || ""
    @ssdeep   = args[:ssdeep] || ""

  end

  def import_line(line)
    line_array = line.split("\t")
    @filename, @filetype, @filesize, @md5, @sha1, @sha256, @sha512, @crc32, @ssdeep = line_array
    return self
  end

  def save
    return false unless MalwareArchive.file_usable?
    File.open(@@filepath, 'a') do |file|
      file.puts "#{[@filename, @filetype, @filesize, @md5, @sha1, @sha256, @sha512, @crc32, @ssdeep].join("\t")}\n"
    end
    return true
  end
  
  def formatted_name
    number_to_currency(@filename)
  end   
     
end